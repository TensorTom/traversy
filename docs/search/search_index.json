{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"traversy Fast data traversal & manipulation tools for Python.Check out the documentation . Quick-Start from traversy import traverse import json jo = json.loads(\"\"\"{ \"2019\": { \"uat\": { \"pkey\": true, \"user\": \"testval\", \"testkey\": true, \"mylist\": [ { \"foo\": \"bar\", \"foo2\": \"bar2\" }, { \"baz\": \"milk\", \"bar\": \"foo\" } ] }, \"dev\": { \"pkey\": true, \"testval\": \"testval\", \"testval2\": true }, \"test1\": [1, 2, \"testval\"], \"test2\": [{\"one\": \"foo\", \"two\": \"bar\", \"three\": \"testval\"}] } }\"\"\") def is_eq(key, val, opath, query): # Use of a filter func is optional. return val == query for node in traverse(jo, is_eq, query=\"milk\"): print(\"Found\", node.key, ':', node.value) # baz : milk print(\"Full path access:\", jo[node.path_str]) # \"2019.uat.mylist.1.baz\" For each iteration, traverse() returns a dict or data object of... {'key', 'value', 'node_path', 'path_str', 'filter_func', 'filter_args': (data, kwargs), 'parent_node', 'output_formatter'} For more information on these non-built-in data structure (Which are optional to use), check out mo-dots and dotty_dict . Changelog 11/15/2020 - 0.1.32 : Fix for pypi. 11/15/2020 - 0.1.3 : Refactored & added more utility methods. 11/13/2020 - 0.1.2 : Doc correction. 11/13/2020 - 0.1.1 : Deprecated set_output_format() and made package compatible with both Python 2 and Python 3. add_sibling ( data , node_path , new_key , new_data , _i = 0 ) Traversal-safe method to add a siblings data node. :param data: The data object you're traversing. :param node_path: List of path segments pointing to the node you're creating a sibling of. Same as node_path of traverse() :param new_key: The sibling key to create. :param new_data: The new data to be stored at the key. Source code in traversy/__init__.py def add_sibling ( data , node_path , new_key , new_data , _i = 0 ): \"\"\" Traversal-safe method to add a siblings data node. :param data: The data object you're traversing. :param node_path: List of path segments pointing to the node you're creating a sibling of. Same as node_path of traverse() :param new_key: The sibling key to create. :param new_data: The new data to be stored at the key. \"\"\" if _i < len ( node_path ) - 1 : return add_sibling ( data [ node_path [ _i ]], node_path , new_key , new_data , _i + 1 ) else : data [ new_key ] = new_data duplicate ( data ) Convenience method for copy.deepcopy() :param data: Any dict, mo-dots, or dotty object. :return: A deep copy of the data. Source code in traversy/__init__.py def duplicate ( data ): \"\"\" Convenience method for copy.deepcopy() :param data: Any dict, mo-dots, or dotty object. :return: A deep copy of the data. \"\"\" return copy . deepcopy ( data ) traverse ( data , filter_func = < function return_all at 0x7f45ceea5ca0 > , node_path = None , parent_node = None , output_formatter = < function func at 0x7f45cf630dc0 > , val_transformer = < function func at 0x7f45cf630dc0 > , ** kwargs ) Traverse deep data structures such as dict, mo-dots, and dotty_dict. Supports nested lists & data. :param data: Data dict or object to traverse :param filter_func: Callback function which returns a boolean filter. :param node_path: Path to start from. :param parent_node: Parent of starting node. :param output_formatter: Function applied to entire return dict. :param val_transformer: Apply func to yielded return val. :param kwargs: All extra keyword args are sent to the filter_func() :return: Source code in traversy/__init__.py def traverse ( data , filter_func = return_all , node_path = None , parent_node = None , output_formatter = func , val_transformer = func , ** kwargs ): \"\"\" Traverse deep data structures such as dict, mo-dots, and dotty_dict. Supports nested lists & data. :param data: Data dict or object to traverse :param filter_func: Callback function which returns a boolean filter. :param node_path: Path to start from. :param parent_node: Parent of starting node. :param output_formatter: Function applied to entire return dict. :param val_transformer: Apply func to yielded return val. :param kwargs: All extra keyword args are sent to the filter_func() :return: \"\"\" node_path = [] if node_path is None else node_path path_str = '.' . join ([ str ( n ) for n in node_path ]) if isinstance ( data , ( dict , Data , Dotty )): for x in data . keys (): local_path = node_path [:] local_path . append ( x ) yield from traverse ( data [ x ], filter_func = filter_func , node_path = local_path , parent_node = data , output_formatter = output_formatter , val_transformer = val_transformer , ** kwargs ) elif isinstance ( data , ( list , FlatList )): for x , y in enumerate ( data ): local_path = node_path [:] local_path . append ( x ) yield from traverse ( data [ x ], filter_func = filter_func , node_path = local_path , parent_node = data , output_formatter = output_formatter , val_transformer = val_transformer , ** kwargs ) elif filter_func ( node_path [ - 1 :], data , node_path , ** kwargs ): key = node_path [ - 1 :][ 0 ] if len ( node_path [ - 1 :]) > 0 else '' yield output_formatter ({ 'key' : key , 'value' : val_transformer ( data ), 'node_path' : node_path , 'path_str' : path_str , 'filter_func' : filter_func . __name__ , 'filter_args' : ( data , kwargs ), 'parent_node' : parent_node , 'output_formatter' : output_formatter . __name__ })","title":"traversy"},{"location":"#traversy_1","text":"Fast data traversal & manipulation tools for Python.Check out the documentation .","title":"traversy"},{"location":"#quick-start","text":"from traversy import traverse import json jo = json.loads(\"\"\"{ \"2019\": { \"uat\": { \"pkey\": true, \"user\": \"testval\", \"testkey\": true, \"mylist\": [ { \"foo\": \"bar\", \"foo2\": \"bar2\" }, { \"baz\": \"milk\", \"bar\": \"foo\" } ] }, \"dev\": { \"pkey\": true, \"testval\": \"testval\", \"testval2\": true }, \"test1\": [1, 2, \"testval\"], \"test2\": [{\"one\": \"foo\", \"two\": \"bar\", \"three\": \"testval\"}] } }\"\"\") def is_eq(key, val, opath, query): # Use of a filter func is optional. return val == query for node in traverse(jo, is_eq, query=\"milk\"): print(\"Found\", node.key, ':', node.value) # baz : milk print(\"Full path access:\", jo[node.path_str]) # \"2019.uat.mylist.1.baz\" For each iteration, traverse() returns a dict or data object of... {'key', 'value', 'node_path', 'path_str', 'filter_func', 'filter_args': (data, kwargs), 'parent_node', 'output_formatter'} For more information on these non-built-in data structure (Which are optional to use), check out mo-dots and dotty_dict .","title":"Quick-Start"},{"location":"#changelog","text":"11/15/2020 - 0.1.32 : Fix for pypi. 11/15/2020 - 0.1.3 : Refactored & added more utility methods. 11/13/2020 - 0.1.2 : Doc correction. 11/13/2020 - 0.1.1 : Deprecated set_output_format() and made package compatible with both Python 2 and Python 3.","title":"Changelog"},{"location":"#traversy","text":"","title":"traversy"},{"location":"#traversy.add_sibling","text":"Traversal-safe method to add a siblings data node. :param data: The data object you're traversing. :param node_path: List of path segments pointing to the node you're creating a sibling of. Same as node_path of traverse() :param new_key: The sibling key to create. :param new_data: The new data to be stored at the key. Source code in traversy/__init__.py def add_sibling ( data , node_path , new_key , new_data , _i = 0 ): \"\"\" Traversal-safe method to add a siblings data node. :param data: The data object you're traversing. :param node_path: List of path segments pointing to the node you're creating a sibling of. Same as node_path of traverse() :param new_key: The sibling key to create. :param new_data: The new data to be stored at the key. \"\"\" if _i < len ( node_path ) - 1 : return add_sibling ( data [ node_path [ _i ]], node_path , new_key , new_data , _i + 1 ) else : data [ new_key ] = new_data","title":"add_sibling()"},{"location":"#traversy.duplicate","text":"Convenience method for copy.deepcopy() :param data: Any dict, mo-dots, or dotty object. :return: A deep copy of the data. Source code in traversy/__init__.py def duplicate ( data ): \"\"\" Convenience method for copy.deepcopy() :param data: Any dict, mo-dots, or dotty object. :return: A deep copy of the data. \"\"\" return copy . deepcopy ( data )","title":"duplicate()"},{"location":"#traversy.traverse","text":"Traverse deep data structures such as dict, mo-dots, and dotty_dict. Supports nested lists & data. :param data: Data dict or object to traverse :param filter_func: Callback function which returns a boolean filter. :param node_path: Path to start from. :param parent_node: Parent of starting node. :param output_formatter: Function applied to entire return dict. :param val_transformer: Apply func to yielded return val. :param kwargs: All extra keyword args are sent to the filter_func() :return: Source code in traversy/__init__.py def traverse ( data , filter_func = return_all , node_path = None , parent_node = None , output_formatter = func , val_transformer = func , ** kwargs ): \"\"\" Traverse deep data structures such as dict, mo-dots, and dotty_dict. Supports nested lists & data. :param data: Data dict or object to traverse :param filter_func: Callback function which returns a boolean filter. :param node_path: Path to start from. :param parent_node: Parent of starting node. :param output_formatter: Function applied to entire return dict. :param val_transformer: Apply func to yielded return val. :param kwargs: All extra keyword args are sent to the filter_func() :return: \"\"\" node_path = [] if node_path is None else node_path path_str = '.' . join ([ str ( n ) for n in node_path ]) if isinstance ( data , ( dict , Data , Dotty )): for x in data . keys (): local_path = node_path [:] local_path . append ( x ) yield from traverse ( data [ x ], filter_func = filter_func , node_path = local_path , parent_node = data , output_formatter = output_formatter , val_transformer = val_transformer , ** kwargs ) elif isinstance ( data , ( list , FlatList )): for x , y in enumerate ( data ): local_path = node_path [:] local_path . append ( x ) yield from traverse ( data [ x ], filter_func = filter_func , node_path = local_path , parent_node = data , output_formatter = output_formatter , val_transformer = val_transformer , ** kwargs ) elif filter_func ( node_path [ - 1 :], data , node_path , ** kwargs ): key = node_path [ - 1 :][ 0 ] if len ( node_path [ - 1 :]) > 0 else '' yield output_formatter ({ 'key' : key , 'value' : val_transformer ( data ), 'node_path' : node_path , 'path_str' : path_str , 'filter_func' : filter_func . __name__ , 'filter_args' : ( data , kwargs ), 'parent_node' : parent_node , 'output_formatter' : output_formatter . __name__ })","title":"traverse()"}]}